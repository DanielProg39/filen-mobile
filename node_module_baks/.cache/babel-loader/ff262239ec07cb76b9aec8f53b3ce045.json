{"ast":null,"code":"import * as language from \"../utils/language\";\nimport * as workers from \"../utils/workers\";\nimport { Capacitor, FilesystemDirectory, Plugins } from \"@capacitor/core\";\nimport imageCompression from 'browser-image-compression';\nimport { call } from \"ionicons/icons\";\n\nconst utils = require(\"../utils/utils\");\n\nexport async function getThumbnailDir(uuid, callback) {\n  if (Capacitor.platform == \"android\") {\n    let path = \"ThumbnailCache/\" + uuid;\n    let directory = FilesystemDirectory.External;\n\n    try {\n      await Plugins.Filesystem.mkdir({\n        path,\n        directory,\n        recursive: true\n      });\n      var uri = await Plugins.Filesystem.getUri({\n        path,\n        directory\n      });\n      return callback(null, {\n        path,\n        directory,\n        uri\n      });\n    } catch (e) {\n      if (e.message == \"Directory exists\") {\n        try {\n          var uri = await Plugins.Filesystem.getUri({\n            path,\n            directory\n          });\n          return callback(null, {\n            path,\n            directory,\n            uri\n          });\n        } catch (e) {\n          return callback(e);\n        }\n      } else {\n        return callback(e);\n      }\n    }\n  } else if (Capacitor.platform == \"ios\") {\n    let path = \"FilenThumbnailCache/\" + uuid;\n    let directory = FilesystemDirectory.Documents;\n\n    try {\n      await Plugins.Filesystem.mkdir({\n        path,\n        directory,\n        recursive: true\n      });\n      var uri = await Plugins.Filesystem.getUri({\n        path,\n        directory\n      });\n      return callback(null, {\n        path,\n        directory,\n        uri\n      });\n    } catch (e) {\n      if (e.message == \"Directory exists\") {\n        try {\n          var uri = await Plugins.Filesystem.getUri({\n            path,\n            directory\n          });\n          return callback(null, {\n            path,\n            directory,\n            uri\n          });\n        } catch (e) {\n          return callback(e);\n        }\n      } else {\n        return callback(e);\n      }\n    }\n  } else {\n    return callback(new Error(\"Can only run getdir function on native ios or android device\"));\n  }\n}\nexport async function getDownloadDir(makeOffline, fileName, callback) {\n  if (Capacitor.platform == \"android\") {\n    if (makeOffline) {\n      let path = \"OfflineFiles/\" + fileName;\n      let directory = FilesystemDirectory.External;\n\n      try {\n        await Plugins.Filesystem.mkdir({\n          path,\n          directory,\n          recursive: true\n        });\n        var uri = await Plugins.Filesystem.getUri({\n          path,\n          directory\n        });\n        return callback(null, {\n          path,\n          directory,\n          uri\n        });\n      } catch (e) {\n        if (e.message == \"Directory exists\") {\n          try {\n            var uri = await Plugins.Filesystem.getUri({\n              path,\n              directory\n            });\n            return callback(null, {\n              path,\n              directory,\n              uri\n            });\n          } catch (e) {\n            return callback(e);\n          }\n        } else {\n          return callback(e);\n        }\n      }\n    } else {\n      let path = \"Download\";\n      let directory = FilesystemDirectory.ExternalStorage;\n\n      try {\n        await Plugins.Filesystem.mkdir({\n          path,\n          directory,\n          recursive: true\n        });\n        var uri = await Plugins.Filesystem.getUri({\n          path,\n          directory\n        });\n        return callback(null, {\n          path,\n          directory,\n          uri\n        });\n      } catch (e) {\n        if (e.message == \"Directory exists\") {\n          try {\n            var uri = await Plugins.Filesystem.getUri({\n              path,\n              directory\n            });\n            return callback(null, {\n              path,\n              directory,\n              uri\n            });\n          } catch (e) {\n            return callback(e);\n          }\n        } else {\n          path = \"Downloads\";\n          directory = FilesystemDirectory.External;\n\n          try {\n            await Plugins.Filesystem.mkdir({\n              path,\n              directory,\n              recursive: true\n            });\n            var uri = await Plugins.Filesystem.getUri({\n              path,\n              directory\n            });\n            return callback(null, {\n              path,\n              directory,\n              uri\n            });\n          } catch (e) {\n            if (e.message == \"Directory exists\") {\n              try {\n                var uri = await Plugins.Filesystem.getUri({\n                  path,\n                  directory\n                });\n                return callback(null, {\n                  path,\n                  directory,\n                  uri\n                });\n              } catch (e) {\n                return callback(e);\n              }\n            } else {\n              return callback(e);\n            }\n          }\n        }\n      }\n    }\n  } else if (Capacitor.platform == \"ios\") {\n    if (makeOffline) {\n      let path = \"FilenOfflineFiles/\" + fileName;\n      let directory = FilesystemDirectory.Documents;\n\n      try {\n        await Plugins.Filesystem.mkdir({\n          path,\n          directory,\n          recursive: true\n        });\n        var uri = await Plugins.Filesystem.getUri({\n          path,\n          directory\n        });\n        return callback(null, {\n          path,\n          directory,\n          uri\n        });\n      } catch (e) {\n        if (e.message == \"Directory exists\") {\n          try {\n            var uri = await Plugins.Filesystem.getUri({\n              path,\n              directory\n            });\n            return callback(null, {\n              path,\n              directory,\n              uri\n            });\n          } catch (e) {\n            return callback(e);\n          }\n        } else {\n          return callback(e);\n        }\n      }\n    } else {\n      let path = \"Filen Downloads\";\n      let directory = FilesystemDirectory.ExternalStorage;\n\n      try {\n        await Plugins.Filesystem.mkdir({\n          path,\n          directory,\n          recursive: true\n        });\n        var uri = await Plugins.Filesystem.getUri({\n          path,\n          directory\n        });\n        return callback(null, {\n          path,\n          directory,\n          uri\n        });\n      } catch (e) {\n        if (e.message == \"Directory exists\") {\n          try {\n            var uri = await Plugins.Filesystem.getUri({\n              path,\n              directory\n            });\n            return callback(null, {\n              path,\n              directory,\n              uri\n            });\n          } catch (e) {\n            return callback(e);\n          }\n        } else {\n          return callback(e);\n        }\n      }\n    }\n  } else {\n    return callback(new Error(\"Can only run getdir function on native ios or android device\"));\n  }\n}\nexport async function downloadFileChunk(file, index, tries, maxTries, callback) {\n  if (tries >= maxTries) {\n    return callback(new Error(\"Max download retries reached for \" + file.uuid + \", returning.\"));\n  }\n\n  if (index >= file.chunks) {\n    return callback(null, index);\n  }\n\n  if (typeof window.customVariables.stoppedDownloads[file.uuid] !== \"undefined\") {\n    return callback(\"stopped\");\n  }\n\n  await window.customVariables.downloadChunkSemaphore.acquire();\n  utils.fetchWithTimeout(3600000, fetch(utils.getDownloadServer() + \"/\" + file.region + \"/\" + file.bucket + \"/\" + file.uuid + \"/\" + index, {\n    method: \"GET\"\n  })).then(response => {\n    if (response.status !== 200) {\n      window.customVariables.downloadChunkSemaphore.release();\n      return setTimeout(() => {\n        this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n      }, 1000);\n    }\n\n    response.arrayBuffer().then(res => {\n      if (typeof window.customVariables.stoppedDownloads[file.uuid] !== \"undefined\") {\n        return callback(\"stopped\");\n      }\n\n      try {\n        if (res.byteLength) {\n          if (res.byteLength > 1) {\n            workers.decryptData(file.uuid, index, file.key, res, decrypted => {\n              window.customVariables.downloadChunkSemaphore.release();\n              return callback(null, index, decrypted);\n            });\n          } else {\n            window.customVariables.downloadChunkSemaphore.release();\n            return setTimeout(() => {\n              this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n            }, 1000);\n          }\n        } else {\n          window.customVariables.downloadChunkSemaphore.release();\n          return setTimeout(() => {\n            this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n          }, 1000);\n        }\n      } catch (e) {\n        console.log(e);\n        window.customVariables.downloadChunkSemaphore.release();\n        return setTimeout(() => {\n          this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n        }, 1000);\n      }\n    }).catch(err => {\n      console.log(err);\n      window.customVariables.downloadChunkSemaphore.release();\n      return setTimeout(() => {\n        this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n      }, 1000);\n    });\n  }).catch(err => {\n    console.log(err);\n    window.customVariables.downloadChunkSemaphore.release();\n    return setTimeout(() => {\n      this.downloadFileChunk(file, index, tries + 1, maxTries, callback);\n    }, 1000);\n  });\n}\nexport async function writeChunkToFile(file, dirObj, uuid, index, data, callback) {\n  if (!window.customVariables.downloads[uuid]) {\n    return callback(new Error(\"Download does not exist\"));\n  }\n\n  if (window.customVariables.downloads[uuid].nextWriteChunk !== index) {\n    return setTimeout(() => {\n      this.writeChunkToFile(file, dirObj, uuid, index, data, callback);\n    }, 50);\n  }\n\n  if (index == 0) {\n    try {\n      await Plugins.Filesystem.deleteFile({\n        path: dirObj.path + \"/\" + file.name,\n        directory: dirObj.directory\n      });\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  workers.convertArrayBufferToBase64(data, async b64Data => {\n    if (index == 0) {\n      try {\n        await Plugins.Filesystem.writeFile({\n          path: dirObj.path + \"/\" + file.name,\n          directory: dirObj.directory,\n          data: b64Data,\n          recursive: true\n        });\n        return callback(null);\n      } catch (e) {\n        return callback(e);\n      }\n    } else {\n      try {\n        await Plugins.Filesystem.appendFile({\n          path: dirObj.path + \"/\" + file.name,\n          directory: dirObj.directory,\n          data: b64Data\n        });\n        return callback(null);\n      } catch (e) {\n        return callback(e);\n      }\n    }\n  });\n}\nexport async function queueFileDownload(file) {\n  if (Capacitor.isNative) {\n    if (this.state.settings.onlyWifi) {\n      let networkStatus = await Plugins.Network.getStatus();\n\n      if (networkStatus.connectionType !== \"wifi\") {\n        return this.spawnToast(language.get(this.state.lang, \"onlyWifiError\"));\n      }\n    }\n  }\n\n  for (let prop in window.customVariables.downloads) {\n    if (window.customVariables.downloads[prop].name == file.name) {\n      return this.spawnToast(language.get(this.state.lang, \"fileDownloadAlreadyDownloadingFile\", true, [\"__NAME__\"], [file.name]));\n    }\n  }\n\n  let uuid = file.uuid;\n  let name = file.name;\n  let size = file.size;\n  let currentIndex = -1;\n  let ext = file.name.split(\".\");\n  ext = ext[ext.length - 1].toLowerCase();\n  let makeOffline = false;\n  let fileName = file.name;\n  window.customVariables.stoppedDownloads[uuid] = undefined;\n  window.customVariables.stoppedDownloadsDone[uuid] = undefined;\n\n  if (typeof file.makeOffline !== \"undefined\") {\n    if (typeof window.customVariables.offlineSavedFiles[file.uuid] !== \"undefined\") {\n      return this.spawnToast(language.get(this.state.lang, \"fileAlreadyStoredOffline\", true, [\"__NAME__\"], [file.name]));\n    }\n\n    makeOffline = true;\n    fileName = file.uuid;\n  }\n\n  this.getDownloadDir(makeOffline, fileName, async (err, dirObj) => {\n    if (err) {\n      console.log(err);\n      return this.spawnToast(language.get(this.state.lang, \"couldNotGetDownloadDir\"));\n    }\n\n    const addToState = () => {\n      let currentDownloads = this.state.downloads;\n      currentDownloads[uuid] = {\n        uuid,\n        size,\n        chunks: file.chunks,\n        name: file.name,\n        mime: file.mime,\n        chunksDone: 0,\n        nextWriteChunk: 0,\n        chunksWritten: 0,\n        loaded: 0,\n        progress: 0,\n        makeOffline: file.makeOffline\n      };\n      window.customVariables.downloads[uuid] = {\n        uuid,\n        size,\n        chunks: file.chunks,\n        name: file.name,\n        mime: file.mime,\n        chunksDone: 0,\n        nextWriteChunk: 0,\n        chunksWritten: 0,\n        loaded: 0,\n        progress: 0,\n        makeOffline: file.makeOffline\n      };\n      return this.setState({\n        downloads: currentDownloads,\n        downloadsCount: this.state.downloadsCount + 1\n      });\n    };\n\n    const removeFromState = () => {\n      let currentDownloads = this.state.downloads;\n      delete currentDownloads[uuid];\n      delete window.customVariables.downloads[uuid];\n      return this.setState({\n        downloads: currentDownloads,\n        downloadsCount: this.state.downloadsCount - 1\n      });\n    };\n\n    const setProgress = progress => {\n      try {\n        let currentDownloads = this.state.downloads;\n        currentDownloads[uuid].progress = progress;\n        window.customVariables.downloads[uuid].progress = progress;\n        return this.setState({\n          downloads: currentDownloads\n        }, () => {\n          this.forceUpdate();\n        });\n      } catch (e) {\n        return console.log(e);\n      }\n    };\n\n    const setLoaded = moreLoaded => {\n      try {\n        let currentDownloads = this.state.downloads;\n        currentDownloads[uuid].loaded += moreLoaded;\n        window.customVariables.downloads[uuid].loaded += moreLoaded;\n        return this.setState({\n          downloads: currentDownloads\n        });\n      } catch (e) {\n        return console.log(e);\n      }\n    };\n\n    const chunksDonePlus = () => {\n      try {\n        let currentDownloads = this.state.downloads;\n        currentDownloads[uuid].chunksDone += 1;\n        window.customVariables.downloads[uuid].chunksDone += 1;\n        return this.setState({\n          downloads: currentDownloads\n        });\n      } catch (e) {\n        return console.log(e);\n      }\n    };\n\n    const chunksWrittenPlus = () => {\n      try {\n        let currentDownloads = this.state.downloads;\n        currentDownloads[uuid].nextWriteChunk += 1;\n        window.customVariables.downloads[uuid].nextWriteChunk += 1;\n        currentDownloads[uuid].chunksWritten += 1;\n        window.customVariables.downloads[uuid].chunksWritten += 1;\n        return this.setState({\n          downloads: currentDownloads\n        });\n      } catch (e) {\n        return console.log(e);\n      }\n    };\n\n    addToState();\n    this.spawnToast(language.get(this.state.lang, \"fileDownloadStarted\", true, [\"__NAME__\"], [file.name]));\n    await window.customVariables.downloadSemaphore.acquire();\n    let downloadInterval = setInterval(() => {\n      currentIndex += 1;\n      let thisIndex = currentIndex;\n\n      if (thisIndex < file.chunks && typeof window.customVariables.downloads[uuid] !== \"undefined\") {\n        this.downloadFileChunk(file, thisIndex, 0, 10, async (err, downloadIndex, downloadData) => {\n          if (err) {\n            console.log(err);\n            window.customVariables.downloadSemaphore.release();\n            removeFromState();\n\n            if (err == \"stopped\") {\n              if (typeof window.customVariables.stoppedDownloadsDone[uuid] == \"undefined\") {\n                window.customVariables.stoppedDownloadsDone[uuid] = true;\n\n                try {\n                  await Plugins.Filesystem.deleteFile({\n                    path: dirObj.path + \"/\" + file.name,\n                    directory: dirObj.directory\n                  });\n                } catch (e) {\n                  console.log(e);\n                }\n\n                return this.spawnToast(language.get(this.state.lang, \"downloadStopped\", true, [\"__NAME__\"], [file.name]));\n              } else {\n                return false;\n              }\n            } else {\n              return this.spawnToast(language.get(this.state.lang, \"fileDownloadError\", true, [\"__NAME__\"], [file.name]));\n            }\n          }\n\n          if (typeof window.customVariables.downloads[uuid] !== \"undefined\") {\n            chunksDonePlus();\n            setLoaded(downloadData.length);\n            this.writeChunkToFile(file, dirObj, uuid, downloadIndex, downloadData, async err => {\n              if (err) {\n                console.log(err);\n                window.customVariables.downloadSemaphore.release();\n                removeFromState();\n                return this.spawnToast(language.get(this.state.lang, \"fileWriteError\", true, [\"__NAME__\"], [file.name]));\n              }\n\n              chunksWrittenPlus();\n\n              try {\n                let progress = (window.customVariables.downloads[uuid].loaded / window.customVariables.downloads[uuid].size * 100).toFixed(2);\n\n                if (progress >= 100) {\n                  progress = 100;\n                }\n\n                setProgress(progress);\n              } catch (e) {\n                console.log(e);\n              }\n\n              try {\n                if (window.customVariables.downloads[uuid].chunksWritten >= window.customVariables.downloads[uuid].chunks) {\n                  if (typeof window.customVariables.downloads[uuid].makeOffline !== \"undefined\") {\n                    window.customVariables.offlineSavedFiles[file.uuid] = true;\n                    let items = this.state.itemList;\n                    let windowItems = window.customVariables.itemList;\n\n                    for (let i = 0; i < items.length; i++) {\n                      if (items[i].uuid == file.uuid) {\n                        items[i].offline = true;\n                      }\n                    }\n\n                    for (let i = 0; i < windowItems.length; i++) {\n                      if (windowItems[i].uuid == file.uuid) {\n                        windowItems[i].offline = true;\n                      }\n                    }\n\n                    this.setState({\n                      itemList: items\n                    });\n                    window.customVariables.itemList = windowItems;\n\n                    if (typeof window.customVariables.cachedFiles[uuid] !== \"undefined\") {\n                      window.customVariables.cachedFiles[uuid].offline = true;\n                    }\n\n                    this.spawnToast(language.get(this.state.lang, \"fileIsNowAvailableOffline\", true, [\"__NAME__\"], [file.name]));\n                    removeFromState();\n                    window.customFunctions.saveOfflineSavedFiles();\n                    window.customVariables.downloadSemaphore.release();\n                    return this.forceUpdate();\n                  } else {\n                    this.spawnToast(language.get(this.state.lang, \"fileDownloadDone\", true, [\"__NAME__\"], [file.name]));\n                    window.customVariables.downloadSemaphore.release();\n                    return removeFromState();\n                  }\n                }\n              } catch (e) {\n                console.log(e);\n              }\n            });\n          }\n        });\n      } else {\n        clearInterval(downloadInterval);\n      }\n    }, 100);\n  });\n}\nexport async function getThumbnail(file, thumbURL, ext) {\n  return new Promise(async (resolve, reject) => {\n    if (Capacitor.isNative) {\n      if (this.state.settings.onlyWifi) {\n        let networkStatus = await Plugins.Network.getStatus();\n\n        if (networkStatus.connectionType !== \"wifi\") {\n          reject(\"only wifi\");\n          return this.spawnToast(language.get(this.state.lang, \"onlyWifiError\"));\n        }\n      }\n    } else {\n      return reject(\"not native\");\n    }\n\n    let dirObj = {\n      path: \"ThumbnailCache/\" + file.uuid,\n      directory: FilesystemDirectory.External\n    };\n    let videoExts = [\"mp4\", \"webm\", \"mov\", \"avi\", \"wmv\"];\n    await window.customVariables.thumbnailSemaphore.acquire();\n\n    if (file.chunks > 16 && !videoExts.includes(ext)) {\n      window.customVariables.thumbnailSemaphore.release();\n      return reject(\"too big\");\n    }\n\n    let thumbnailFileName = file.name;\n\n    if (videoExts.includes(ext)) {\n      let nameEx = file.name.split(\".\");\n      nameEx[nameEx.length - 1] = \"jpg\";\n      thumbnailFileName = nameEx.join(\".\");\n    }\n\n    if (typeof window.customVariables.thumbnailCache[file.uuid] == \"undefined\") {\n      if (thumbURL !== window.location.href) {\n        window.customVariables.thumbnailSemaphore.release();\n        return reject(\"url changed\");\n      }\n\n      const writeThumbnail = async arrayBuffer => {\n        workers.convertArrayBufferToBase64(arrayBuffer, async b64Data => {\n          try {\n            await Plugins.Filesystem.writeFile({\n              path: dirObj.path + \"/\" + thumbnailFileName,\n              directory: dirObj.directory,\n              data: b64Data,\n              recursive: true\n            });\n            var uri = await Plugins.Filesystem.getUri({\n              path: dirObj.path + \"/\" + thumbnailFileName,\n              directory: dirObj.directory\n            });\n          } catch (e) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(e);\n          }\n\n          if (thumbURL !== window.location.href) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(\"url changed\");\n          }\n\n          let imageURL = window.Ionic.WebView.convertFileSrc(uri.uri);\n          window.customVariables.thumbnailBlobCache[file.uuid] = imageURL;\n          window.customVariables.thumbnailCache[file.uuid] = true;\n          window.customVariables.thumbnailSemaphore.release();\n          return resolve(imageURL);\n        });\n      };\n\n      if (videoExts.includes(ext)) {\n        this.downloadPreview(file, undefined, async (err, downloadData) => {\n          if (err) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(err);\n          }\n\n          downloadData = new File([new Blob([downloadData], {\n            type: file.mime\n          })], file.name, {\n            lastModified: new Date(),\n            type: file.mime\n          });\n\n          try {\n            var thumbnailData = await utils.getVideoCover(downloadData);\n          } catch (e) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(e);\n          }\n\n          thumbnailData = new File([thumbnailData], thumbnailFileName, {\n            lastModified: new Date(),\n            type: \"image/jpeg\"\n          });\n\n          try {\n            var compressedImage = await imageCompression(thumbnailData, {\n              maxWidthOrHeight: 200,\n              useWebWorker: true\n            });\n          } catch (e) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(e);\n          }\n\n          let fileReader = new FileReader();\n\n          fileReader.onload = e => {\n            let arrayBuffer = e.target.result;\n            return writeThumbnail(arrayBuffer);\n          };\n\n          fileReader.onerror = err => {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(err);\n          };\n\n          fileReader.readAsArrayBuffer(compressedImage);\n        }, 5, true);\n      } else {\n        this.downloadPreview(file, undefined, async (err, data) => {\n          if (err) {\n            window.customVariables.thumbnailSemaphore.release();\n            return reject(err);\n          }\n\n          if (utils.canCompressThumbnail(ext)) {\n            data = new File([new Blob([data], {\n              type: file.mime\n            })], thumbnailFileName, {\n              lastModified: new Date(),\n              type: file.mime\n            });\n\n            try {\n              var compressedImage = await imageCompression(data, {\n                maxWidthOrHeight: 200,\n                useWebWorker: true\n              });\n            } catch (e) {\n              window.customVariables.thumbnailSemaphore.release();\n              return reject(e);\n            }\n\n            let fileReader = new FileReader();\n\n            fileReader.onload = e => {\n              let arrayBuffer = e.target.result;\n              return writeThumbnail(arrayBuffer);\n            };\n\n            fileReader.onerror = err => {\n              window.customVariables.thumbnailSemaphore.release();\n              return reject(err);\n            };\n\n            fileReader.readAsArrayBuffer(compressedImage);\n          } else {\n            return writeThumbnail(data);\n          }\n        }, Infinity, true);\n      }\n    } else {\n      try {\n        var stat = await Plugins.Filesystem.stat({\n          path: dirObj.path + \"/\" + thumbnailFileName,\n          directory: dirObj.directory\n        });\n      } catch (e) {\n        window.customVariables.thumbnailSemaphore.release();\n        delete window.customVariables.thumbnailCache[file.uuid];\n        return reject(e);\n      }\n\n      if (typeof stat.size == \"undefined\") {\n        window.customVariables.thumbnailSemaphore.release();\n        delete window.customVariables.thumbnailCache[file.uuid];\n        return reject(\"Thumbnail not found on device, it might have been deleted\");\n      }\n\n      if (stat.size <= 0) {\n        window.customVariables.thumbnailSemaphore.release();\n        delete window.customVariables.thumbnailCache[file.uuid];\n        return reject(\"Thumbnail not found on device, it might have been deleted\");\n      }\n\n      try {\n        var uri = await Plugins.Filesystem.getUri({\n          path: dirObj.path + \"/\" + thumbnailFileName,\n          directory: dirObj.directory\n        });\n      } catch (e) {\n        window.customVariables.thumbnailSemaphore.release();\n        delete window.customVariables.thumbnailCache[file.uuid];\n        return reject(e);\n      }\n\n      if (thumbURL !== window.location.href) {\n        window.customVariables.thumbnailSemaphore.release();\n        return reject(\"url changed\");\n      }\n\n      let imageURL = window.Ionic.WebView.convertFileSrc(uri.uri);\n      window.customVariables.thumbnailBlobCache[file.uuid] = imageURL;\n      window.customVariables.thumbnailCache[file.uuid] = true;\n      window.customVariables.thumbnailSemaphore.release();\n      return resolve(imageURL);\n    }\n  });\n}\nexport async function downloadPreview(file, progressCallback, callback, maxChunks = Infinity, isThumbnailDownload = false) {\n  let dataArray = [];\n  let currentIndex = -1;\n  let currentWriteIndex = 0;\n  let chunksDone = 0;\n\n  const write = (index, data, callback) => {\n    if (currentWriteIndex == index) {\n      dataArray.push(data);\n      currentWriteIndex += 1;\n      chunksDone += 1;\n\n      if (typeof progressCallback == \"function\") {\n        progressCallback(chunksDone);\n      }\n\n      if (chunksDone == file.chunks || chunksDone == maxChunks) {\n        return callback(null, utils.uInt8ArrayConcat(dataArray));\n      }\n    } else {\n      return setTimeout(() => {\n        write(index, data, callback);\n      }, 50);\n    }\n  };\n\n  let downloadInterval = setInterval(() => {\n    currentIndex += 1;\n    let thisIndex = currentIndex;\n\n    if (isThumbnailDownload) {\n      window.customVariables.stopGettingPreviewData = false;\n    }\n\n    if (thisIndex < file.chunks && thisIndex < maxChunks && !window.customVariables.stopGettingPreviewData) {\n      this.downloadFileChunk(file, thisIndex, 0, 32, (err, downloadIndex, downloadData) => {\n        if (isThumbnailDownload) {\n          window.customVariables.stopGettingPreviewData = false;\n        }\n\n        if (err) {\n          return callback(err);\n        }\n\n        write(downloadIndex, downloadData, callback);\n      });\n    } else {\n      if (window.customVariables.stopGettingPreviewData && !isThumbnailDownload) {\n        window.customVariables.isGettingPreviewData = false;\n        callback(\"stopped\");\n      }\n\n      clearInterval(downloadInterval);\n    }\n  }, 100);\n}","map":{"version":3,"sources":["/Users/jan/Documents/filen/app/src/components/download.js"],"names":["language","workers","Capacitor","FilesystemDirectory","Plugins","imageCompression","call","utils","require","getThumbnailDir","uuid","callback","platform","path","directory","External","Filesystem","mkdir","recursive","uri","getUri","e","message","Documents","Error","getDownloadDir","makeOffline","fileName","ExternalStorage","downloadFileChunk","file","index","tries","maxTries","chunks","window","customVariables","stoppedDownloads","downloadChunkSemaphore","acquire","fetchWithTimeout","fetch","getDownloadServer","region","bucket","method","then","response","status","release","setTimeout","arrayBuffer","res","byteLength","decryptData","key","decrypted","console","log","catch","err","writeChunkToFile","dirObj","data","downloads","nextWriteChunk","deleteFile","name","convertArrayBufferToBase64","b64Data","writeFile","appendFile","queueFileDownload","isNative","state","settings","onlyWifi","networkStatus","Network","getStatus","connectionType","spawnToast","get","lang","prop","size","currentIndex","ext","split","length","toLowerCase","undefined","stoppedDownloadsDone","offlineSavedFiles","addToState","currentDownloads","mime","chunksDone","chunksWritten","loaded","progress","setState","downloadsCount","removeFromState","setProgress","forceUpdate","setLoaded","moreLoaded","chunksDonePlus","chunksWrittenPlus","downloadSemaphore","downloadInterval","setInterval","thisIndex","downloadIndex","downloadData","toFixed","items","itemList","windowItems","i","offline","cachedFiles","customFunctions","saveOfflineSavedFiles","clearInterval","getThumbnail","thumbURL","Promise","resolve","reject","videoExts","thumbnailSemaphore","includes","thumbnailFileName","nameEx","join","thumbnailCache","location","href","writeThumbnail","imageURL","Ionic","WebView","convertFileSrc","thumbnailBlobCache","downloadPreview","File","Blob","type","lastModified","Date","thumbnailData","getVideoCover","compressedImage","maxWidthOrHeight","useWebWorker","fileReader","FileReader","onload","target","result","onerror","readAsArrayBuffer","canCompressThumbnail","Infinity","stat","progressCallback","maxChunks","isThumbnailDownload","dataArray","currentWriteIndex","write","push","uInt8ArrayConcat","stopGettingPreviewData","isGettingPreviewData"],"mappings":"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","sourcesContent":["import * as language from \"../utils/language\"\r\nimport * as workers from \"../utils/workers\"\r\nimport { Capacitor, FilesystemDirectory, Plugins } from \"@capacitor/core\"\r\nimport imageCompression from 'browser-image-compression';\r\nimport { call } from \"ionicons/icons\";\r\n\r\nconst utils = require(\"../utils/utils\")\r\n\r\nexport async function getThumbnailDir(uuid, callback){\r\n    if(Capacitor.platform == \"android\"){\r\n        let path = \"ThumbnailCache/\" + uuid\r\n        let directory = FilesystemDirectory.External\r\n\r\n        try{\r\n            await Plugins.Filesystem.mkdir({\r\n                path,\r\n                directory,\r\n                recursive: true \r\n            })\r\n\r\n            var uri = await Plugins.Filesystem.getUri({\r\n                path,\r\n                directory\r\n            })\r\n\r\n            return callback(null, {\r\n                path,\r\n                directory,\r\n                uri\r\n            })\r\n        }\r\n        catch(e){\r\n            if(e.message == \"Directory exists\"){\r\n                try{\r\n                    var uri = await Plugins.Filesystem.getUri({\r\n                        path,\r\n                        directory\r\n                    })\r\n\r\n                    return callback(null, {\r\n                        path,\r\n                        directory,\r\n                        uri\r\n                    })\r\n                }\r\n                catch(e){\r\n                    return callback(e)\r\n                }\r\n            }\r\n            else{\r\n                return callback(e)\r\n            }\r\n        }\r\n    }\r\n    else if(Capacitor.platform == \"ios\"){\r\n        let path = \"FilenThumbnailCache/\" + uuid\r\n        let directory = FilesystemDirectory.Documents\r\n\r\n        try{\r\n            await Plugins.Filesystem.mkdir({\r\n                path,\r\n                directory,\r\n                recursive: true \r\n            })\r\n\r\n            var uri = await Plugins.Filesystem.getUri({\r\n                path,\r\n                directory\r\n            })\r\n\r\n            return callback(null, {\r\n                path,\r\n                directory,\r\n                uri\r\n            })\r\n        }\r\n        catch(e){\r\n            if(e.message == \"Directory exists\"){\r\n                try{\r\n                    var uri = await Plugins.Filesystem.getUri({\r\n                        path,\r\n                        directory\r\n                    })\r\n\r\n                    return callback(null, {\r\n                        path,\r\n                        directory,\r\n                        uri\r\n                    })\r\n                }\r\n                catch(e){\r\n                    return callback(e)\r\n                }\r\n            }\r\n            else{\r\n                return callback(e)\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        return callback(new Error(\"Can only run getdir function on native ios or android device\"))\r\n    }\r\n}\r\n\r\nexport async function getDownloadDir(makeOffline, fileName, callback){\r\n    if(Capacitor.platform == \"android\"){\r\n        if(makeOffline){\r\n            let path = \"OfflineFiles/\" + fileName\r\n            let directory = FilesystemDirectory.External\r\n\r\n            try{\r\n                await Plugins.Filesystem.mkdir({\r\n                    path,\r\n                    directory,\r\n                    recursive: true \r\n                })\r\n\r\n                var uri = await Plugins.Filesystem.getUri({\r\n                    path,\r\n                    directory\r\n                })\r\n\r\n                return callback(null, {\r\n                    path,\r\n                    directory,\r\n                    uri\r\n                })\r\n            }\r\n            catch(e){\r\n                if(e.message == \"Directory exists\"){\r\n                    try{\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path,\r\n                            directory\r\n                        })\r\n\r\n                        return callback(null, {\r\n                            path,\r\n                            directory,\r\n                            uri\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        return callback(e)\r\n                    }\r\n                }\r\n                else{\r\n                    return callback(e)\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            let path = \"Download\"\r\n            let directory = FilesystemDirectory.ExternalStorage\r\n\r\n            try{\r\n                await Plugins.Filesystem.mkdir({\r\n                    path,\r\n                    directory,\r\n                    recursive: true \r\n                })\r\n\r\n                var uri = await Plugins.Filesystem.getUri({\r\n                    path,\r\n                    directory\r\n                })\r\n\r\n                return callback(null, {\r\n                    path,\r\n                    directory,\r\n                    uri\r\n                })\r\n            }\r\n            catch(e){\r\n                if(e.message == \"Directory exists\"){\r\n                    try{\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path,\r\n                            directory\r\n                        })\r\n\r\n                        return callback(null, {\r\n                            path,\r\n                            directory,\r\n                            uri\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        return callback(e)\r\n                    }\r\n                }\r\n                else{\r\n                    path = \"Downloads\"\r\n                    directory = FilesystemDirectory.External\r\n                    \r\n                    try{\r\n                        await Plugins.Filesystem.mkdir({\r\n                            path,\r\n                            directory,\r\n                            recursive: true \r\n                        })\r\n\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path,\r\n                            directory\r\n                        })\r\n\r\n                        return callback(null, {\r\n                            path,\r\n                            directory,\r\n                            uri\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        if(e.message == \"Directory exists\"){\r\n                            try{\r\n                                var uri = await Plugins.Filesystem.getUri({\r\n                                    path,\r\n                                    directory\r\n                                })\r\n\r\n                                return callback(null, {\r\n                                    path,\r\n                                    directory,\r\n                                    uri\r\n                                })\r\n                            }\r\n                            catch(e){\r\n                                return callback(e)\r\n                            }\r\n                        }\r\n                        else{\r\n                            return callback(e)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if(Capacitor.platform == \"ios\"){\r\n        if(makeOffline){\r\n            let path = \"FilenOfflineFiles/\" + fileName\r\n            let directory = FilesystemDirectory.Documents\r\n\r\n            try{\r\n                await Plugins.Filesystem.mkdir({\r\n                    path,\r\n                    directory,\r\n                    recursive: true \r\n                })\r\n\r\n                var uri = await Plugins.Filesystem.getUri({\r\n                    path,\r\n                    directory\r\n                })\r\n\r\n                return callback(null, {\r\n                    path,\r\n                    directory,\r\n                    uri\r\n                })\r\n            }\r\n            catch(e){\r\n                if(e.message == \"Directory exists\"){\r\n                    try{\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path,\r\n                            directory\r\n                        })\r\n\r\n                        return callback(null, {\r\n                            path,\r\n                            directory,\r\n                            uri\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        return callback(e)\r\n                    }\r\n                }\r\n                else{\r\n                    return callback(e)\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            let path = \"Filen Downloads\"\r\n            let directory = FilesystemDirectory.ExternalStorage\r\n\r\n            try{\r\n                await Plugins.Filesystem.mkdir({\r\n                    path,\r\n                    directory,\r\n                    recursive: true \r\n                })\r\n\r\n                var uri = await Plugins.Filesystem.getUri({\r\n                    path,\r\n                    directory\r\n                })\r\n\r\n                return callback(null, {\r\n                    path,\r\n                    directory,\r\n                    uri\r\n                })\r\n            }\r\n            catch(e){\r\n                if(e.message == \"Directory exists\"){\r\n                    try{\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path,\r\n                            directory\r\n                        })\r\n\r\n                        return callback(null, {\r\n                            path,\r\n                            directory,\r\n                            uri\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        return callback(e)\r\n                    }\r\n                }\r\n                else{\r\n                    return callback(e)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        return callback(new Error(\"Can only run getdir function on native ios or android device\"))\r\n    }\r\n}\r\n\r\nexport async function downloadFileChunk(file, index, tries, maxTries, callback){\r\n    if(tries >= maxTries){\r\n\t\treturn callback(new Error(\"Max download retries reached for \" + file.uuid + \", returning.\"))\r\n\t}\r\n\r\n\tif(index >= file.chunks){\r\n\t\treturn callback(null, index)\r\n    }\r\n\r\n    if(typeof window.customVariables.stoppedDownloads[file.uuid] !== \"undefined\"){\r\n        return callback(\"stopped\")\r\n    }\r\n\r\n    await window.customVariables.downloadChunkSemaphore.acquire()\r\n\r\n    utils.fetchWithTimeout(3600000, fetch(utils.getDownloadServer() + \"/\" + file.region + \"/\" + file.bucket + \"/\" + file.uuid + \"/\" + index, {\r\n        method: \"GET\"\r\n    })).then((response) => {\r\n        if(response.status !== 200){\r\n            window.customVariables.downloadChunkSemaphore.release()\r\n\r\n            return setTimeout(() => {\r\n                this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n            }, 1000)\r\n        }\r\n\r\n        response.arrayBuffer().then((res) => {\r\n            if(typeof window.customVariables.stoppedDownloads[file.uuid] !== \"undefined\"){\r\n                return callback(\"stopped\")\r\n            }\r\n\r\n            try{\r\n                if(res.byteLength){\r\n                    if(res.byteLength > 1){\r\n                        workers.decryptData(file.uuid, index, file.key, res, (decrypted) => {\r\n                            window.customVariables.downloadChunkSemaphore.release()\r\n    \r\n                            return callback(null, index, decrypted)\r\n                        })\r\n                    }\r\n                    else{\r\n                        window.customVariables.downloadChunkSemaphore.release()\r\n\r\n                        return setTimeout(() => {\r\n                            this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n                        }, 1000)\r\n                    }\r\n                }\r\n                else{\r\n                    window.customVariables.downloadChunkSemaphore.release()\r\n\r\n                    return setTimeout(() => {\r\n                        this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n                    }, 1000)\r\n                }\r\n            }\r\n            catch(e){\r\n                console.log(e)\r\n\r\n                window.customVariables.downloadChunkSemaphore.release()\r\n\r\n                return setTimeout(() => {\r\n                    this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n                }, 1000)\r\n            }\r\n        }).catch((err) => {\r\n            console.log(err)\r\n\r\n            window.customVariables.downloadChunkSemaphore.release()\r\n\r\n            return setTimeout(() => {\r\n                this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n            }, 1000)\r\n        })\r\n    }).catch((err) => {\r\n        console.log(err)\r\n\r\n        window.customVariables.downloadChunkSemaphore.release()\r\n\r\n        return setTimeout(() => {\r\n            this.downloadFileChunk(file, index, (tries + 1), maxTries, callback)\r\n        }, 1000)\r\n    })\r\n}\r\n\r\nexport async function writeChunkToFile(file, dirObj, uuid, index, data, callback){\r\n    if(!window.customVariables.downloads[uuid]){\r\n        return callback(new Error(\"Download does not exist\"))\r\n    }\r\n\r\n    if(window.customVariables.downloads[uuid].nextWriteChunk !== index){\r\n        return setTimeout(() => {\r\n            this.writeChunkToFile(file, dirObj, uuid, index, data, callback)\r\n        }, 50)\r\n    }\r\n\r\n    if(index == 0){\r\n        try{\r\n            await Plugins.Filesystem.deleteFile({\r\n                path: dirObj.path + \"/\" + file.name,\r\n                directory: dirObj.directory\r\n            })\r\n        }\r\n        catch(e){\r\n            console.log(e)\r\n        }\r\n    }\r\n\r\n    workers.convertArrayBufferToBase64(data, async (b64Data) => {\r\n        if(index == 0){\r\n            try{\r\n                await Plugins.Filesystem.writeFile({\r\n                    path: dirObj.path + \"/\" + file.name,\r\n                    directory: dirObj.directory,\r\n                    data: b64Data,\r\n                    recursive: true\r\n                })\r\n    \r\n                return callback(null)\r\n            }\r\n            catch(e){\r\n                return callback(e)\r\n            }\r\n        }\r\n        else{\r\n            try{\r\n                await Plugins.Filesystem.appendFile({\r\n                    path: dirObj.path + \"/\" + file.name,\r\n                    directory: dirObj.directory,\r\n                    data: b64Data\r\n                })\r\n    \r\n                return callback(null)\r\n            }\r\n            catch(e){\r\n                return callback(e)\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nexport async function queueFileDownload(file){\r\n    if(Capacitor.isNative){\r\n        if(this.state.settings.onlyWifi){\r\n            let networkStatus = await Plugins.Network.getStatus()\r\n\r\n            if(networkStatus.connectionType !== \"wifi\"){\r\n                return this.spawnToast(language.get(this.state.lang, \"onlyWifiError\"))\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let prop in window.customVariables.downloads){\r\n\t\tif(window.customVariables.downloads[prop].name == file.name){\r\n\t\t\treturn this.spawnToast(language.get(this.state.lang, \"fileDownloadAlreadyDownloadingFile\", true, [\"__NAME__\"], [file.name]))\r\n\t\t}\r\n    }\r\n    \r\n    let uuid = file.uuid\r\n\tlet name = file.name\r\n\tlet size = file.size\r\n\tlet currentIndex = -1\r\n\r\n\tlet ext = file.name.split(\".\")\r\n\text = ext[ext.length - 1].toLowerCase()\r\n\r\n    let makeOffline = false\r\n    let fileName = file.name\r\n\r\n    window.customVariables.stoppedDownloads[uuid] = undefined\r\n    window.customVariables.stoppedDownloadsDone[uuid] = undefined\r\n\r\n\tif(typeof file.makeOffline !== \"undefined\"){\r\n        if(typeof window.customVariables.offlineSavedFiles[file.uuid] !== \"undefined\"){\r\n            return this.spawnToast(language.get(this.state.lang, \"fileAlreadyStoredOffline\", true, [\"__NAME__\"], [file.name]))\r\n        }\r\n\r\n        makeOffline = true\r\n        fileName = file.uuid\r\n    }\r\n\r\n    this.getDownloadDir(makeOffline, fileName, async (err, dirObj) => {\r\n        if(err){\r\n            console.log(err)\r\n\r\n            return this.spawnToast(language.get(this.state.lang, \"couldNotGetDownloadDir\"))\r\n        }\r\n\r\n        const addToState = () => {\r\n\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\tcurrentDownloads[uuid] = {\r\n\t\t\t\tuuid,\r\n\t\t\t\tsize,\r\n                chunks: file.chunks,\r\n                name: file.name,\r\n                mime: file.mime,\r\n                chunksDone: 0,\r\n                nextWriteChunk: 0,\r\n                chunksWritten: 0,\r\n\t\t\t\tloaded: 0,\r\n                progress: 0,\r\n                makeOffline: file.makeOffline\r\n\t\t\t}\r\n\r\n\t\t\twindow.customVariables.downloads[uuid] = {\r\n\t\t\t\tuuid,\r\n\t\t\t\tsize,\r\n                chunks: file.chunks,\r\n                name: file.name,\r\n                mime: file.mime,\r\n                chunksDone: 0,\r\n                nextWriteChunk: 0,\r\n                chunksWritten: 0,\r\n\t\t\t\tloaded: 0,\r\n                progress: 0,\r\n                makeOffline: file.makeOffline\r\n\t\t\t}\r\n\r\n\t\t\treturn this.setState({\r\n\t\t\t\tdownloads: currentDownloads,\r\n\t\t\t\tdownloadsCount: (this.state.downloadsCount + 1)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst removeFromState = () => {\r\n\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\tdelete currentDownloads[uuid]\r\n\t\t\tdelete window.customVariables.downloads[uuid]\r\n\r\n\t\t\treturn this.setState({\r\n\t\t\t\tdownloads: currentDownloads,\r\n\t\t\t\tdownloadsCount: (this.state.downloadsCount - 1)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst setProgress = (progress) => {\r\n\t\t\ttry{\r\n\t\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\t\tcurrentDownloads[uuid].progress = progress\r\n\t\t\t\twindow.customVariables.downloads[uuid].progress = progress\r\n\r\n\t\t\t\treturn this.setState({\r\n\t\t\t\t\tdownloads: currentDownloads\r\n\t\t\t\t}, () => {\r\n                    this.forceUpdate()\r\n                })\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t\treturn console.log(e)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst setLoaded = (moreLoaded) => {\r\n\t\t\ttry{\r\n\t\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\t\tcurrentDownloads[uuid].loaded += moreLoaded\r\n\t\t\t\twindow.customVariables.downloads[uuid].loaded += moreLoaded\r\n\r\n\t\t\t\treturn this.setState({\r\n\t\t\t\t\tdownloads: currentDownloads\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t\treturn console.log(e)\r\n\t\t\t}\r\n        }\r\n        \r\n        const chunksDonePlus = () => {\r\n            try{\r\n\t\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\t\tcurrentDownloads[uuid].chunksDone += 1\r\n\t\t\t\twindow.customVariables.downloads[uuid].chunksDone += 1\r\n\r\n\t\t\t\treturn this.setState({\r\n\t\t\t\t\tdownloads: currentDownloads\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t\treturn console.log(e)\r\n\t\t\t}\r\n        }\r\n\r\n        const chunksWrittenPlus = () => {\r\n            try{\r\n\t\t\t\tlet currentDownloads = this.state.downloads\r\n\r\n\t\t\t\tcurrentDownloads[uuid].nextWriteChunk += 1\r\n                window.customVariables.downloads[uuid].nextWriteChunk += 1\r\n                currentDownloads[uuid].chunksWritten += 1\r\n\t\t\t\twindow.customVariables.downloads[uuid].chunksWritten += 1\r\n\r\n\t\t\t\treturn this.setState({\r\n\t\t\t\t\tdownloads: currentDownloads\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tcatch(e){\r\n\t\t\t\treturn console.log(e)\r\n\t\t\t}\r\n        }\r\n\r\n\t\taddToState()\r\n\r\n        this.spawnToast(language.get(this.state.lang, \"fileDownloadStarted\", true, [\"__NAME__\"], [file.name]))\r\n\r\n        await window.customVariables.downloadSemaphore.acquire()\r\n        \r\n        let downloadInterval = setInterval(() => {\r\n            currentIndex += 1\r\n\r\n            let thisIndex = currentIndex\r\n\r\n            if(thisIndex < file.chunks && typeof window.customVariables.downloads[uuid] !== \"undefined\"){\r\n                this.downloadFileChunk(file, thisIndex, 0, 10, async (err, downloadIndex, downloadData) => {\r\n                    if(err){\r\n                        console.log(err)\r\n\r\n                        window.customVariables.downloadSemaphore.release()\r\n\r\n                        removeFromState()\r\n\r\n                        if(err == \"stopped\"){\r\n                            if(typeof window.customVariables.stoppedDownloadsDone[uuid] == \"undefined\"){\r\n                                window.customVariables.stoppedDownloadsDone[uuid] = true\r\n\r\n                                try{\r\n                                    await Plugins.Filesystem.deleteFile({\r\n                                        path: dirObj.path + \"/\" + file.name,\r\n                                        directory: dirObj.directory\r\n                                    })\r\n                                }\r\n                                catch(e){\r\n                                    console.log(e)\r\n                                }\r\n\r\n                                return this.spawnToast(language.get(this.state.lang, \"downloadStopped\", true, [\"__NAME__\"], [file.name]))\r\n                            }\r\n                            else{\r\n                                return false\r\n                            }\r\n                        }\r\n                        else{\r\n                            return this.spawnToast(language.get(this.state.lang, \"fileDownloadError\", true, [\"__NAME__\"], [file.name]))\r\n                        }\r\n                    }\r\n\r\n                    if(typeof window.customVariables.downloads[uuid] !== \"undefined\"){\r\n                        chunksDonePlus()\r\n                        setLoaded(downloadData.length)\r\n                        \r\n                        this.writeChunkToFile(file, dirObj, uuid, downloadIndex, downloadData, async (err) => {\r\n                            if(err){\r\n                                console.log(err)\r\n\r\n                                window.customVariables.downloadSemaphore.release()\r\n\r\n                                removeFromState()\r\n\r\n                                return this.spawnToast(language.get(this.state.lang, \"fileWriteError\", true, [\"__NAME__\"], [file.name]))\r\n                            }\r\n\r\n                            chunksWrittenPlus()\r\n\r\n                            try{\r\n                                let progress = ((window.customVariables.downloads[uuid].loaded / window.customVariables.downloads[uuid].size) * 100).toFixed(2)\r\n    \r\n                                if(progress >= 100){\r\n                                    progress = 100\r\n                                }\r\n    \r\n                                setProgress(progress)\r\n                            }\r\n                            catch(e){\r\n                                console.log(e)\r\n                            }\r\n\r\n                            try{\r\n                                if(window.customVariables.downloads[uuid].chunksWritten >= window.customVariables.downloads[uuid].chunks){\r\n                                    if(typeof window.customVariables.downloads[uuid].makeOffline !== \"undefined\"){\r\n                                        window.customVariables.offlineSavedFiles[file.uuid] = true\r\n    \r\n                                        let items = this.state.itemList\r\n                                        let windowItems = window.customVariables.itemList\r\n    \r\n                                        for(let i = 0; i < items.length; i++){\r\n                                            if(items[i].uuid == file.uuid){\r\n                                                items[i].offline = true\r\n                                            }\r\n                                        }\r\n    \r\n                                        for(let i = 0; i < windowItems.length; i++){\r\n                                            if(windowItems[i].uuid == file.uuid){\r\n                                                windowItems[i].offline = true\r\n                                            }\r\n                                        }\r\n    \r\n                                        this.setState({\r\n                                            itemList: items\r\n                                        })\r\n    \r\n                                        window.customVariables.itemList = windowItems\r\n                                        \r\n                                        if(typeof window.customVariables.cachedFiles[uuid] !== \"undefined\"){\r\n                                            window.customVariables.cachedFiles[uuid].offline = true\r\n                                        }\r\n                            \r\n                                        this.spawnToast(language.get(this.state.lang, \"fileIsNowAvailableOffline\", true, [\"__NAME__\"], [file.name]))\r\n    \r\n                                        removeFromState()\r\n    \r\n                                        window.customFunctions.saveOfflineSavedFiles()\r\n    \r\n                                        window.customVariables.downloadSemaphore.release()\r\n                                        \r\n                                        return this.forceUpdate()\r\n                                    }\r\n                                    else{\r\n                                        this.spawnToast(language.get(this.state.lang, \"fileDownloadDone\", true, [\"__NAME__\"], [file.name]))\r\n    \r\n                                        window.customVariables.downloadSemaphore.release()\r\n    \r\n                                        return removeFromState()\r\n                                    }\r\n                                }  \r\n                            }\r\n                            catch(e){\r\n                                console.log(e)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n            else{\r\n                clearInterval(downloadInterval)\r\n            }\r\n        }, 100)\r\n    })\r\n}\r\n\r\nexport async function getThumbnail(file, thumbURL, ext){\r\n    return new Promise(async (resolve, reject) => {\r\n        if(Capacitor.isNative){\r\n            if(this.state.settings.onlyWifi){\r\n                let networkStatus = await Plugins.Network.getStatus()\r\n    \r\n                if(networkStatus.connectionType !== \"wifi\"){\r\n                    reject(\"only wifi\")\r\n\r\n                    return this.spawnToast(language.get(this.state.lang, \"onlyWifiError\"))\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            return reject(\"not native\")\r\n        }\r\n\r\n        let dirObj = {\r\n            path: \"ThumbnailCache/\" + file.uuid,\r\n            directory: FilesystemDirectory.External\r\n        }\r\n\r\n        let videoExts = [\"mp4\", \"webm\", \"mov\", \"avi\", \"wmv\"]\r\n    \r\n        await window.customVariables.thumbnailSemaphore.acquire()\r\n\r\n        if(file.chunks > 16 && !videoExts.includes(ext)){\r\n            window.customVariables.thumbnailSemaphore.release()\r\n\r\n            return reject(\"too big\")\r\n        }\r\n\r\n        let thumbnailFileName = file.name\r\n\r\n        if(videoExts.includes(ext)){\r\n            let nameEx = file.name.split(\".\")\r\n\r\n            nameEx[nameEx.length - 1] = \"jpg\"\r\n\r\n            thumbnailFileName = nameEx.join(\".\")\r\n        }\r\n\r\n        if(typeof window.customVariables.thumbnailCache[file.uuid] == \"undefined\"){\r\n            if(thumbURL !== window.location.href){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                return reject(\"url changed\")\r\n            }\r\n\r\n            const writeThumbnail = async (arrayBuffer) => {\r\n                workers.convertArrayBufferToBase64(arrayBuffer, async (b64Data) => {\r\n                    try{\r\n                        await Plugins.Filesystem.writeFile({\r\n                            path: dirObj.path + \"/\" + thumbnailFileName,\r\n                            directory: dirObj.directory,\r\n                            data: b64Data,\r\n                            recursive: true\r\n                        })\r\n\r\n                        var uri = await Plugins.Filesystem.getUri({\r\n                            path: dirObj.path + \"/\" + thumbnailFileName,\r\n                            directory: dirObj.directory\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n\r\n                        return reject(e)\r\n                    }\r\n\r\n                    if(thumbURL !== window.location.href){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n        \r\n                        return reject(\"url changed\")\r\n                    }\r\n\r\n                    let imageURL = window.Ionic.WebView.convertFileSrc(uri.uri)\r\n\r\n                    window.customVariables.thumbnailBlobCache[file.uuid] = imageURL\r\n                    window.customVariables.thumbnailCache[file.uuid] = true\r\n\r\n                    window.customVariables.thumbnailSemaphore.release()\r\n\r\n                    return resolve(imageURL)\r\n                })\r\n            }\r\n\r\n            if(videoExts.includes(ext)){\r\n                this.downloadPreview(file, undefined, async (err, downloadData) => {\r\n                    if(err){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n    \r\n                        return reject(err)\r\n                    }\r\n\r\n                    downloadData = new File([new Blob([downloadData], {\r\n                        type: file.mime\r\n                    })], file.name, {\r\n                        lastModified: new Date(),\r\n                        type: file.mime\r\n                    })\r\n    \r\n                    try{\r\n                        var thumbnailData = await utils.getVideoCover(downloadData)\r\n                    }\r\n                    catch(e){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n    \r\n                        return reject(e)\r\n                    }\r\n\r\n                    thumbnailData = new File([thumbnailData], thumbnailFileName, {\r\n                        lastModified: new Date(),\r\n                        type: \"image/jpeg\"\r\n                    })\r\n\r\n                    try{\r\n                        var compressedImage = await imageCompression(thumbnailData, {\r\n                            maxWidthOrHeight: 200,\r\n                            useWebWorker: true\r\n                        })\r\n                    }\r\n                    catch(e){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n    \r\n                        return reject(e)\r\n                    }\r\n    \r\n                    let fileReader = new FileReader()\r\n    \r\n                    fileReader.onload = (e) => {\r\n                        let arrayBuffer = e.target.result\r\n    \r\n                        return writeThumbnail(arrayBuffer)\r\n                    }\r\n    \r\n                    fileReader.onerror = (err) => {\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n    \r\n                        return reject(err)\r\n                    }\r\n    \r\n                    fileReader.readAsArrayBuffer(compressedImage)\r\n                }, 5, true)\r\n            }\r\n            else{\r\n                this.downloadPreview(file, undefined, async (err, data) => {\r\n                    if(err){\r\n                        window.customVariables.thumbnailSemaphore.release()\r\n    \r\n                        return reject(err)\r\n                    }\r\n    \r\n                    if(utils.canCompressThumbnail(ext)){\r\n                        data = new File([new Blob([data], {\r\n                            type: file.mime\r\n                        })], thumbnailFileName, {\r\n                            lastModified: new Date(),\r\n                            type: file.mime\r\n                        })\r\n        \r\n                        try{\r\n                            var compressedImage = await imageCompression(data, {\r\n                                maxWidthOrHeight: 200,\r\n                                useWebWorker: true\r\n                            })\r\n                        }\r\n                        catch(e){\r\n                            window.customVariables.thumbnailSemaphore.release()\r\n        \r\n                            return reject(e)\r\n                        }\r\n        \r\n                        let fileReader = new FileReader()\r\n        \r\n                        fileReader.onload = (e) => {\r\n                            let arrayBuffer = e.target.result\r\n        \r\n                            return writeThumbnail(arrayBuffer)\r\n                        }\r\n        \r\n                        fileReader.onerror = (err) => {\r\n                            window.customVariables.thumbnailSemaphore.release()\r\n        \r\n                            return reject(err)\r\n                        }\r\n        \r\n                        fileReader.readAsArrayBuffer(compressedImage)\r\n                    }\r\n                    else{\r\n                        return writeThumbnail(data)\r\n                    }\r\n                }, Infinity, true)\r\n            }\r\n        }\r\n        else{\r\n            try{\r\n                var stat = await Plugins.Filesystem.stat({\r\n                    path: dirObj.path + \"/\" + thumbnailFileName,\r\n                    directory: dirObj.directory\r\n                })\r\n            }\r\n            catch(e){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                delete window.customVariables.thumbnailCache[file.uuid]\r\n\r\n                return reject(e)\r\n            }\r\n\r\n            if(typeof stat.size == \"undefined\"){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                delete window.customVariables.thumbnailCache[file.uuid]\r\n\r\n                return reject(\"Thumbnail not found on device, it might have been deleted\")\r\n            }\r\n\r\n            if(stat.size <= 0){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                delete window.customVariables.thumbnailCache[file.uuid]\r\n\r\n                return reject(\"Thumbnail not found on device, it might have been deleted\")\r\n            }\r\n\r\n            try{\r\n                var uri = await Plugins.Filesystem.getUri({\r\n                    path: dirObj.path + \"/\" + thumbnailFileName,\r\n                    directory: dirObj.directory\r\n                })\r\n            }\r\n            catch(e){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                delete window.customVariables.thumbnailCache[file.uuid]\r\n\r\n                return reject(e)\r\n            }\r\n\r\n            if(thumbURL !== window.location.href){\r\n                window.customVariables.thumbnailSemaphore.release()\r\n\r\n                return reject(\"url changed\")\r\n            }\r\n\r\n            let imageURL = window.Ionic.WebView.convertFileSrc(uri.uri)\r\n\r\n            window.customVariables.thumbnailBlobCache[file.uuid] = imageURL\r\n            window.customVariables.thumbnailCache[file.uuid] = true\r\n\r\n            window.customVariables.thumbnailSemaphore.release()\r\n\r\n            return resolve(imageURL)\r\n        }\r\n    })\r\n}\r\n\r\nexport async function downloadPreview(file, progressCallback, callback, maxChunks = Infinity, isThumbnailDownload = false){\r\n    let dataArray = []\r\n    let currentIndex = -1\r\n    let currentWriteIndex = 0\r\n    let chunksDone = 0\r\n    \r\n    const write = (index, data, callback) => {\r\n        if(currentWriteIndex == index){\r\n            dataArray.push(data)\r\n\r\n            currentWriteIndex += 1\r\n            chunksDone += 1\r\n\r\n            if(typeof progressCallback == \"function\"){\r\n                progressCallback(chunksDone)\r\n            }\r\n\r\n            if(chunksDone == file.chunks || chunksDone == maxChunks){\r\n                return callback(null, utils.uInt8ArrayConcat(dataArray))\r\n            }\r\n        }\r\n        else{\r\n            return setTimeout(() => {\r\n                write(index, data, callback)\r\n            }, 50)\r\n        }\r\n    }\r\n\r\n    let downloadInterval = setInterval(() => {\r\n        currentIndex += 1\r\n\r\n        let thisIndex = currentIndex\r\n\r\n        if(isThumbnailDownload){\r\n            window.customVariables.stopGettingPreviewData = false\r\n        }\r\n\r\n        if(thisIndex < file.chunks && thisIndex < maxChunks && !window.customVariables.stopGettingPreviewData){\r\n            this.downloadFileChunk(file, thisIndex, 0, 32, (err, downloadIndex, downloadData) => {\r\n                if(isThumbnailDownload){\r\n                    window.customVariables.stopGettingPreviewData = false\r\n                }\r\n\r\n                if(err){\r\n                    return callback(err)\r\n                }\r\n\r\n                write(downloadIndex, downloadData, callback)\r\n            })\r\n        }\r\n        else{\r\n            if(window.customVariables.stopGettingPreviewData && !isThumbnailDownload){\r\n                window.customVariables.isGettingPreviewData = false\r\n                \r\n                callback(\"stopped\")\r\n            }\r\n\r\n            clearInterval(downloadInterval)\r\n        }\r\n    }, 100)\r\n}"]},"metadata":{},"sourceType":"module"}